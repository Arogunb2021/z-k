(window.webpackJsonp = window.webpackJsonp || []).push([
    [41], {
        1159: function(r, t, e) {
            "use strict";
            e.d(t, "a", (function() {
                return o
            })), e.d(t, "b", (function() {
                return n
            }));
            var n = {};
            e.r(n), e.d(n, "AbiCoder", (function() {
                return c.a
            })), e.d(n, "defaultAbiCoder", (function() {
                return c.b
            })), e.d(n, "Fragment", (function() {
                return l.e
            })), e.d(n, "ConstructorFragment", (function() {
                return l.a
            })), e.d(n, "ErrorFragment", (function() {
                return l.b
            })), e.d(n, "EventFragment", (function() {
                return l.c
            })), e.d(n, "FunctionFragment", (function() {
                return l.f
            })), e.d(n, "ParamType", (function() {
                return l.g
            })), e.d(n, "FormatTypes", (function() {
                return l.d
            })), e.d(n, "checkResultErrors", (function() {
                return f.d
            })), e.d(n, "Logger", (function() {
                return Hr.a
            })), e.d(n, "RLP", (function() {
                return Qr
            })), e.d(n, "_fetchData", (function() {
                return ut.a
            })), e.d(n, "fetchJson", (function() {
                return ut.b
            })), e.d(n, "poll", (function() {
                return ut.c
            })), e.d(n, "checkProperties", (function() {
                return qr.a
            })), e.d(n, "deepCopy", (function() {
                return qr.b
            })), e.d(n, "defineReadOnly", (function() {
                return qr.c
            })), e.d(n, "getStatic", (function() {
                return qr.d
            })), e.d(n, "resolveProperties", (function() {
                return qr.e
            })), e.d(n, "shallowCopy", (function() {
                return qr.f
            })), e.d(n, "arrayify", (function() {
                return kr.a
            })), e.d(n, "concat", (function() {
                return kr.b
            })), e.d(n, "stripZeros", (function() {
                return kr.o
            })), e.d(n, "zeroPad", (function() {
                return kr.p
            })), e.d(n, "isBytes", (function() {
                return kr.j
            })), e.d(n, "isBytesLike", (function() {
                return kr.k
            })), e.d(n, "defaultPath", (function() {
                return Xr.b
            })), e.d(n, "HDNode", (function() {
                return Xr.a
            })), e.d(n, "SigningKey", (function() {
                return Yr.a
            })), e.d(n, "Interface", (function() {
                return h.b
            })), e.d(n, "LogDescription", (function() {
                return h.c
            })), e.d(n, "TransactionDescription", (function() {
                return h.d
            })), e.d(n, "base58", (function() {
                return Fr.a
            })), e.d(n, "base64", (function() {
                return Mr
            })), e.d(n, "hexlify", (function() {
                return kr.i
            })), e.d(n, "isHexString", (function() {
                return kr.l
            })), e.d(n, "hexConcat", (function() {
                return kr.c
            })), e.d(n, "hexStripZeros", (function() {
                return kr.f
            })), e.d(n, "hexValue", (function() {
                return kr.g
            })), e.d(n, "hexZeroPad", (function() {
                return kr.h
            })), e.d(n, "hexDataLength", (function() {
                return kr.d
            })), e.d(n, "hexDataSlice", (function() {
                return kr.e
            })), e.d(n, "nameprep", (function() {
                return tt.a
            })), e.d(n, "_toEscapedUtf8String", (function() {
                return et.d
            })), e.d(n, "toUtf8Bytes", (function() {
                return et.f
            })), e.d(n, "toUtf8CodePoints", (function() {
                return et.g
            })), e.d(n, "toUtf8String", (function() {
                return et.h
            })), e.d(n, "Utf8ErrorFuncs", (function() {
                return et.b
            })), e.d(n, "formatBytes32String", (function() {
                return nt.a
            })), e.d(n, "parseBytes32String", (function() {
                return nt.b
            })), e.d(n, "hashMessage", (function() {
                return Gr.a
            })), e.d(n, "namehash", (function() {
                return Br.b
            })), e.d(n, "isValidName", (function() {
                return Br.a
            })), e.d(n, "id", (function() {
                return Wr.a
            })), e.d(n, "_TypedDataEncoder", (function() {
                return zr.a
            })), e.d(n, "getAddress", (function() {
                return Pr
            })), e.d(n, "getIcapAddress", (function() {
                return xr
            })), e.d(n, "getContractAddress", (function() {
                return Dr
            })), e.d(n, "getCreate2Address", (function() {
                return Lr
            })), e.d(n, "isAddress", (function() {
                return vr
            })), e.d(n, "formatEther", (function() {
                return it.b
            })), e.d(n, "parseEther", (function() {
                return it.d
            })), e.d(n, "formatUnits", (function() {
                return it.c
            })), e.d(n, "parseUnits", (function() {
                return it.e
            })), e.d(n, "commify", (function() {
                return it.a
            })), e.d(n, "computeHmac", (function() {
                return Vr.a
            })), e.d(n, "keccak256", (function() {
                return Kr.a
            })), e.d(n, "ripemd160", (function() {
                return Vr.b
            })), e.d(n, "sha256", (function() {
                return Vr.c
            })), e.d(n, "sha512", (function() {
                return Vr.d
            })), e.d(n, "randomBytes", (function() {
                return $r.a
            })), e.d(n, "shuffled", (function() {
                return Zr.a
            })), e.d(n, "solidityPack", (function() {
                return Jr.b
            })), e.d(n, "solidityKeccak256", (function() {
                return Jr.a
            })), e.d(n, "soliditySha256", (function() {
                return Jr.c
            })), e.d(n, "splitSignature", (function() {
                return kr.n
            })), e.d(n, "joinSignature", (function() {
                return kr.m
            })), e.d(n, "accessListify", (function() {
                return ot.b
            })), e.d(n, "parseTransaction", (function() {
                return ot.d
            })), e.d(n, "serializeTransaction", (function() {
                return ot.f
            })), e.d(n, "TransactionTypes", (function() {
                return ot.a
            })), e.d(n, "getJsonWalletAddress", (function() {
                return jr.a
            })), e.d(n, "computeAddress", (function() {
                return ot.c
            })), e.d(n, "recoverAddress", (function() {
                return ot.e
            })), e.d(n, "computePublicKey", (function() {
                return Yr.b
            })), e.d(n, "recoverPublicKey", (function() {
                return Yr.c
            })), e.d(n, "verifyMessage", (function() {
                return st.a
            })), e.d(n, "verifyTypedData", (function() {
                return st.b
            })), e.d(n, "getAccountPath", (function() {
                return Xr.d
            })), e.d(n, "mnemonicToEntropy", (function() {
                return Xr.f
            })), e.d(n, "entropyToMnemonic", (function() {
                return Xr.c
            })), e.d(n, "isValidMnemonic", (function() {
                return Xr.e
            })), e.d(n, "mnemonicToSeed", (function() {
                return Xr.g
            })), e.d(n, "SupportedAlgorithm", (function() {
                return at.a
            })), e.d(n, "UnicodeNormalizationForm", (function() {
                return et.a
            })), e.d(n, "Utf8ErrorReason", (function() {
                return et.c
            })), e.d(n, "Indexed", (function() {
                return h.a
            }));
            var o = e(448),
                c = e(1143),
                l = e(150),
                f = e(83),
                h = e(1772);
            let E = !1,
                d = !1;
            const N = {
                debug: 1,
                default: 2,
                info: 2,
                warning: 3,
                error: 4,
                off: 5
            };
            let m = N.default,
                R = null;
            const A = function() {
                try {
                    const r = [];
                    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((form => {
                            try {
                                if ("test" !== "test".normalize(form)) throw new Error("bad normalize")
                            } catch (t) {
                                r.push(form)
                            }
                        })), r.length) throw new Error("missing " + r.join(", "));
                    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
                } catch (r) {
                    return r.message
                }
                return null
            }();
            var I, w;
            ! function(r) {
                r.DEBUG = "DEBUG", r.INFO = "INFO", r.WARNING = "WARNING", r.ERROR = "ERROR", r.OFF = "OFF"
            }(I || (I = {})),
            function(r) {
                r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", r.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", r.NETWORK_ERROR = "NETWORK_ERROR", r.SERVER_ERROR = "SERVER_ERROR", r.TIMEOUT = "TIMEOUT", r.BUFFER_OVERRUN = "BUFFER_OVERRUN", r.NUMERIC_FAULT = "NUMERIC_FAULT", r.MISSING_NEW = "MISSING_NEW", r.INVALID_ARGUMENT = "INVALID_ARGUMENT", r.MISSING_ARGUMENT = "MISSING_ARGUMENT", r.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", r.CALL_EXCEPTION = "CALL_EXCEPTION", r.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", r.NONCE_EXPIRED = "NONCE_EXPIRED", r.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", r.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", r.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", r.ACTION_REJECTED = "ACTION_REJECTED"
            }(w || (w = {}));
            const U = "0123456789abcdef";
            class S {
                constructor(r) {
                    Object.defineProperty(this, "version", {
                        enumerable: !0,
                        value: r,
                        writable: !1
                    })
                }
                _log(r, t) {
                    const e = r.toLowerCase();
                    null == N[e] && this.throwArgumentError("invalid log level name", "logLevel", r), m > N[e] || console.log.apply(console, t)
                }
                debug(...r) {
                    this._log(S.levels.DEBUG, r)
                }
                info(...r) {
                    this._log(S.levels.INFO, r)
                }
                warn(...r) {
                    this._log(S.levels.WARNING, r)
                }
                makeError(r, code, t) {
                    if (d) return this.makeError("censored error", code, {});
                    code || (code = S.errors.UNKNOWN_ERROR), t || (t = {});
                    const e = [];
                    Object.keys(t).forEach((r => {
                        const n = t[r];
                        try {
                            if (n instanceof Uint8Array) {
                                let t = "";
                                for (let i = 0; i < n.length; i++) t += U[n[i] >> 4], t += U[15 & n[i]];
                                e.push(r + "=Uint8Array(0x" + t + ")")
                            } else e.push(r + "=" + JSON.stringify(n))
                        } catch (n) {
                            e.push(r + "=" + JSON.stringify(t[r].toString()))
                        }
                    })), e.push(`code=${code}`), e.push(`version=${this.version}`);
                    const n = r;
                    let o = "";
                    switch (code) {
                        case w.NUMERIC_FAULT:
                            {
                                o = "NUMERIC_FAULT";
                                const t = r;
                                switch (t) {
                                    case "overflow":
                                    case "underflow":
                                    case "division-by-zero":
                                        o += "-" + t;
                                        break;
                                    case "negative-power":
                                    case "negative-width":
                                        o += "-unsupported";
                                        break;
                                    case "unbound-bitwise-result":
                                        o += "-unbound-result"
                                }
                                break
                            }
                        case w.CALL_EXCEPTION:
                        case w.INSUFFICIENT_FUNDS:
                        case w.MISSING_NEW:
                        case w.NONCE_EXPIRED:
                        case w.REPLACEMENT_UNDERPRICED:
                        case w.TRANSACTION_REPLACED:
                        case w.UNPREDICTABLE_GAS_LIMIT:
                            o = code
                    }
                    o && (r += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), e.length && (r += " (" + e.join(", ") + ")");
                    const c = new Error(r);
                    return c.reason = n, c.code = code, Object.keys(t).forEach((function(r) {
                        c[r] = t[r]
                    })), c
                }
                throwError(r, code, t) {
                    throw this.makeError(r, code, t)
                }
                throwArgumentError(r, t, e) {
                    return this.throwError(r, S.errors.INVALID_ARGUMENT, {
                        argument: t,
                        value: e
                    })
                }
                assert(r, t, code, e) {
                    r || this.throwError(t, code, e)
                }
                assertArgument(r, t, e, n) {
                    r || this.throwArgumentError(t, e, n)
                }
                checkNormalize(r) {
                    null == r && (r = "platform missing String.prototype.normalize"), A && this.throwError("platform missing String.prototype.normalize", S.errors.UNSUPPORTED_OPERATION, {
                        operation: "String.prototype.normalize",
                        form: A
                    })
                }
                checkSafeUint53(r, t) {
                    "number" == typeof r && (null == t && (t = "value not safe"), (r < 0 || r >= 9007199254740991) && this.throwError(t, S.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "out-of-safe-range",
                        value: r
                    }), r % 1 && this.throwError(t, S.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "non-integer",
                        value: r
                    }))
                }
                checkArgumentCount(r, t, e) {
                    e = e ? ": " + e : "", r < t && this.throwError("missing argument" + e, S.errors.MISSING_ARGUMENT, {
                        count: r,
                        expectedCount: t
                    }), r > t && this.throwError("too many arguments" + e, S.errors.UNEXPECTED_ARGUMENT, {
                        count: r,
                        expectedCount: t
                    })
                }
                checkNew(r, t) {
                    r !== Object && null != r || this.throwError("missing new", S.errors.MISSING_NEW, {
                        name: t.name
                    })
                }
                checkAbstract(r, t) {
                    r === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", S.errors.UNSUPPORTED_OPERATION, {
                        name: r.name,
                        operation: "new"
                    }) : r !== Object && null != r || this.throwError("missing new", S.errors.MISSING_NEW, {
                        name: t.name
                    })
                }
                static globalLogger() {
                    return R || (R = new S("logger/5.7.0")), R
                }
                static setCensorship(r, t) {
                    if (!r && t && this.globalLogger().throwError("cannot permanently disable censorship", S.errors.UNSUPPORTED_OPERATION, {
                            operation: "setCensorship"
                        }), E) {
                        if (!r) return;
                        this.globalLogger().throwError("error censorship permanent", S.errors.UNSUPPORTED_OPERATION, {
                            operation: "setCensorship"
                        })
                    }
                    d = !!r, E = !!t
                }
                static setLogLevel(r) {
                    const t = N[r.toLowerCase()];
                    null != t ? m = t : S.globalLogger().warn("invalid log level - " + r)
                }
                static from(r) {
                    return new S(r)
                }
            }
            S.errors = w, S.levels = I;
            const T = new S("bytes/5.7.0");

            function _(r) {
                return !!r.toHexString
            }

            function y(r) {
                return r.slice || (r.slice = function() {
                    const t = Array.prototype.slice.call(arguments);
                    return y(new Uint8Array(Array.prototype.slice.apply(r, t)))
                }), r
            }

            function O(r) {
                return D(r) && !(r.length % 2) || P(r)
            }

            function C(r) {
                return "number" == typeof r && r == r && r % 1 == 0
            }

            function P(r) {
                if (null == r) return !1;
                if (r.constructor === Uint8Array) return !0;
                if ("string" == typeof r) return !1;
                if (!C(r.length) || r.length < 0) return !1;
                for (let i = 0; i < r.length; i++) {
                    const t = r[i];
                    if (!C(t) || t < 0 || t >= 256) return !1
                }
                return !0
            }

            function v(r, t) {
                if (t || (t = {}), "number" == typeof r) {
                    T.checkSafeUint53(r, "invalid arrayify value");
                    const t = [];
                    for (; r;) t.unshift(255 & r), r = parseInt(String(r / 256));
                    return 0 === t.length && t.push(0), y(new Uint8Array(t))
                }
                if (t.allowMissingPrefix && "string" == typeof r && "0x" !== r.substring(0, 2) && (r = "0x" + r), _(r) && (r = r.toHexString()), D(r)) {
                    let e = r.substring(2);
                    e.length % 2 && ("left" === t.hexPad ? e = "0" + e : "right" === t.hexPad ? e += "0" : T.throwArgumentError("hex data is odd-length", "value", r));
                    const n = [];
                    for (let i = 0; i < e.length; i += 2) n.push(parseInt(e.substring(i, i + 2), 16));
                    return y(new Uint8Array(n))
                }
                return P(r) ? y(new Uint8Array(r)) : T.throwArgumentError("invalid arrayify value", "value", r)
            }

            function x(r) {
                const t = r.map((r => v(r))),
                    e = t.reduce(((r, t) => r + t.length), 0),
                    n = new Uint8Array(e);
                return t.reduce(((r, object) => (n.set(object, r), r + object.length)), 0), y(n)
            }

            function D(r, t) {
                return !("string" != typeof r || !r.match(/^0x[0-9A-Fa-f]*$/)) && (!t || r.length === 2 + 2 * t)
            }
            const L = "0123456789abcdef";

            function M(r, t) {
                if (t || (t = {}), "number" == typeof r) {
                    T.checkSafeUint53(r, "invalid hexlify value");
                    let t = "";
                    for (; r;) t = L[15 & r] + t, r = Math.floor(r / 16);
                    return t.length ? (t.length % 2 && (t = "0" + t), "0x" + t) : "0x00"
                }
                if ("bigint" == typeof r) return (r = r.toString(16)).length % 2 ? "0x0" + r : "0x" + r;
                if (t.allowMissingPrefix && "string" == typeof r && "0x" !== r.substring(0, 2) && (r = "0x" + r), _(r)) return r.toHexString();
                if (D(r)) return r.length % 2 && ("left" === t.hexPad ? r = "0x0" + r.substring(2) : "right" === t.hexPad ? r += "0" : T.throwArgumentError("hex data is odd-length", "value", r)), r.toLowerCase();
                if (P(r)) {
                    let t = "0x";
                    for (let i = 0; i < r.length; i++) {
                        let e = r[i];
                        t += L[(240 & e) >> 4] + L[15 & e]
                    }
                    return t
                }
                return T.throwArgumentError("invalid hexlify value", "value", r)
            }

            function F(data) {
                if ("string" != typeof data) data = M(data);
                else if (!D(data) || data.length % 2) return null;
                return (data.length - 2) / 2
            }

            function k(data, r, t) {
                return "string" != typeof data ? data = M(data) : (!D(data) || data.length % 2) && T.throwArgumentError("invalid hexData", "value", data), r = 2 + 2 * r, null != t ? "0x" + data.substring(r, 2 + 2 * t) : "0x" + data.substring(r)
            }
            var G = e(13),
                B = e.n(G);
            let W = !1,
                z = !1;
            const X = {
                debug: 1,
                default: 2,
                info: 2,
                warning: 3,
                error: 4,
                off: 5
            };
            let j = X.default,
                K = null;
            const H = function() {
                try {
                    const r = [];
                    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((form => {
                            try {
                                if ("test" !== "test".normalize(form)) throw new Error("bad normalize")
                            } catch (t) {
                                r.push(form)
                            }
                        })), r.length) throw new Error("missing " + r.join(", "));
                    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
                } catch (r) {
                    return r.message
                }
                return null
            }();
            var V, J;
            ! function(r) {
                r.DEBUG = "DEBUG", r.INFO = "INFO", r.WARNING = "WARNING", r.ERROR = "ERROR", r.OFF = "OFF"
            }(V || (V = {})),
            function(r) {
                r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", r.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", r.NETWORK_ERROR = "NETWORK_ERROR", r.SERVER_ERROR = "SERVER_ERROR", r.TIMEOUT = "TIMEOUT", r.BUFFER_OVERRUN = "BUFFER_OVERRUN", r.NUMERIC_FAULT = "NUMERIC_FAULT", r.MISSING_NEW = "MISSING_NEW", r.INVALID_ARGUMENT = "INVALID_ARGUMENT", r.MISSING_ARGUMENT = "MISSING_ARGUMENT", r.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", r.CALL_EXCEPTION = "CALL_EXCEPTION", r.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", r.NONCE_EXPIRED = "NONCE_EXPIRED", r.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", r.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", r.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"
            }(J || (J = {}));
            const $ = "0123456789abcdef";
            class Z {
                constructor(r) {
                    Object.defineProperty(this, "version", {
                        enumerable: !0,
                        value: r,
                        writable: !1
                    })
                }
                _log(r, t) {
                    const e = r.toLowerCase();
                    null == X[e] && this.throwArgumentError("invalid log level name", "logLevel", r), j > X[e] || console.log.apply(console, t)
                }
                debug(...r) {
                    this._log(Z.levels.DEBUG, r)
                }
                info(...r) {
                    this._log(Z.levels.INFO, r)
                }
                warn(...r) {
                    this._log(Z.levels.WARNING, r)
                }
                makeError(r, code, t) {
                    if (z) return this.makeError("censored error", code, {});
                    code || (code = Z.errors.UNKNOWN_ERROR), t || (t = {});
                    const e = [];
                    Object.keys(t).forEach((r => {
                        const n = t[r];
                        try {
                            if (n instanceof Uint8Array) {
                                let t = "";
                                for (let i = 0; i < n.length; i++) t += $[n[i] >> 4], t += $[15 & n[i]];
                                e.push(r + "=Uint8Array(0x" + t + ")")
                            } else e.push(r + "=" + JSON.stringify(n))
                        } catch (n) {
                            e.push(r + "=" + JSON.stringify(t[r].toString()))
                        }
                    })), e.push(`code=${code}`), e.push(`version=${this.version}`);
                    const n = r;
                    let o = "";
                    switch (code) {
                        case J.NUMERIC_FAULT:
                            {
                                o = "NUMERIC_FAULT";
                                const t = r;
                                switch (t) {
                                    case "overflow":
                                    case "underflow":
                                    case "division-by-zero":
                                        o += "-" + t;
                                        break;
                                    case "negative-power":
                                    case "negative-width":
                                        o += "-unsupported";
                                        break;
                                    case "unbound-bitwise-result":
                                        o += "-unbound-result"
                                }
                                break
                            }
                        case J.CALL_EXCEPTION:
                        case J.INSUFFICIENT_FUNDS:
                        case J.MISSING_NEW:
                        case J.NONCE_EXPIRED:
                        case J.REPLACEMENT_UNDERPRICED:
                        case J.TRANSACTION_REPLACED:
                        case J.UNPREDICTABLE_GAS_LIMIT:
                            o = code
                    }
                    o && (r += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), e.length && (r += " (" + e.join(", ") + ")");
                    const c = new Error(r);
                    return c.reason = n, c.code = code, Object.keys(t).forEach((function(r) {
                        c[r] = t[r]
                    })), c
                }
                throwError(r, code, t) {
                    throw this.makeError(r, code, t)
                }
                throwArgumentError(r, t, e) {
                    return this.throwError(r, Z.errors.INVALID_ARGUMENT, {
                        argument: t,
                        value: e
                    })
                }
                assert(r, t, code, e) {
                    r || this.throwError(t, code, e)
                }
                assertArgument(r, t, e, n) {
                    r || this.throwArgumentError(t, e, n)
                }
                checkNormalize(r) {
                    null == r && (r = "platform missing String.prototype.normalize"), H && this.throwError("platform missing String.prototype.normalize", Z.errors.UNSUPPORTED_OPERATION, {
                        operation: "String.prototype.normalize",
                        form: H
                    })
                }
                checkSafeUint53(r, t) {
                    "number" == typeof r && (null == t && (t = "value not safe"), (r < 0 || r >= 9007199254740991) && this.throwError(t, Z.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "out-of-safe-range",
                        value: r
                    }), r % 1 && this.throwError(t, Z.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "non-integer",
                        value: r
                    }))
                }
                checkArgumentCount(r, t, e) {
                    e = e ? ": " + e : "", r < t && this.throwError("missing argument" + e, Z.errors.MISSING_ARGUMENT, {
                        count: r,
                        expectedCount: t
                    }), r > t && this.throwError("too many arguments" + e, Z.errors.UNEXPECTED_ARGUMENT, {
                        count: r,
                        expectedCount: t
                    })
                }
                checkNew(r, t) {
                    r !== Object && null != r || this.throwError("missing new", Z.errors.MISSING_NEW, {
                        name: t.name
                    })
                }
                checkAbstract(r, t) {
                    r === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", Z.errors.UNSUPPORTED_OPERATION, {
                        name: r.name,
                        operation: "new"
                    }) : r !== Object && null != r || this.throwError("missing new", Z.errors.MISSING_NEW, {
                        name: t.name
                    })
                }
                static globalLogger() {
                    return K || (K = new Z("logger/5.6.0")), K
                }
                static setCensorship(r, t) {
                    if (!r && t && this.globalLogger().throwError("cannot permanently disable censorship", Z.errors.UNSUPPORTED_OPERATION, {
                            operation: "setCensorship"
                        }), W) {
                        if (!r) return;
                        this.globalLogger().throwError("error censorship permanent", Z.errors.UNSUPPORTED_OPERATION, {
                            operation: "setCensorship"
                        })
                    }
                    z = !!r, W = !!t
                }
                static setLogLevel(r) {
                    const t = X[r.toLowerCase()];
                    null != t ? j = t : Z.globalLogger().warn("invalid log level - " + r)
                }
                static from(r) {
                    return new Z(r)
                }
            }
            Z.errors = J, Z.levels = V;
            const Q = new Z("bytes/5.6.1");

            function Y(r) {
                return !!r.toHexString
            }

            function rr(r) {
                return "number" == typeof r && r == r && r % 1 == 0
            }

            function er(r) {
                if (null == r) return !1;
                if (r.constructor === Uint8Array) return !0;
                if ("string" == typeof r) return !1;
                if (!rr(r.length) || r.length < 0) return !1;
                for (let i = 0; i < r.length; i++) {
                    const t = r[i];
                    if (!rr(t) || t < 0 || t >= 256) return !1
                }
                return !0
            }

            function nr(r, t) {
                return !("string" != typeof r || !r.match(/^0x[0-9A-Fa-f]*$/)) && (!t || r.length === 2 + 2 * t)
            }
            const or = "0123456789abcdef";

            function ir(r, t) {
                if (t || (t = {}), "number" == typeof r) {
                    Q.checkSafeUint53(r, "invalid hexlify value");
                    let t = "";
                    for (; r;) t = or[15 & r] + t, r = Math.floor(r / 16);
                    return t.length ? (t.length % 2 && (t = "0" + t), "0x" + t) : "0x00"
                }
                if ("bigint" == typeof r) return (r = r.toString(16)).length % 2 ? "0x0" + r : "0x" + r;
                if (t.allowMissingPrefix && "string" == typeof r && "0x" !== r.substring(0, 2) && (r = "0x" + r), Y(r)) return r.toHexString();
                if (nr(r)) return r.length % 2 && ("left" === t.hexPad ? r = "0x0" + r.substring(2) : "right" === t.hexPad ? r += "0" : Q.throwArgumentError("hex data is odd-length", "value", r)), r.toLowerCase();
                if (er(r)) {
                    let t = "0x";
                    for (let i = 0; i < r.length; i++) {
                        let e = r[i];
                        t += or[(240 & e) >> 4] + or[15 & e]
                    }
                    return t
                }
                return Q.throwArgumentError("invalid hexlify value", "value", r)
            }
            var sr = B.a.BN;
            const ur = new Z("bignumber/5.6.0"),
                ar = {},
                cr = 9007199254740991;
            let lr = !1;
            class fr {
                constructor(r, t) {
                    ur.checkNew(new.target, fr), r !== ar && ur.throwError("cannot call constructor directly; use BigNumber.from", Z.errors.UNSUPPORTED_OPERATION, {
                        operation: "new (BigNumber)"
                    }), this._hex = t, this._isBigNumber = !0, Object.freeze(this)
                }
                fromTwos(r) {
                    return Er(dr(this).fromTwos(r))
                }
                toTwos(r) {
                    return Er(dr(this).toTwos(r))
                }
                abs() {
                    return "-" === this._hex[0] ? fr.from(this._hex.substring(1)) : this
                }
                add(r) {
                    return Er(dr(this).add(dr(r)))
                }
                sub(r) {
                    return Er(dr(this).sub(dr(r)))
                }
                div(r) {
                    return fr.from(r).isZero() && Nr("division-by-zero", "div"), Er(dr(this).div(dr(r)))
                }
                mul(r) {
                    return Er(dr(this).mul(dr(r)))
                }
                mod(r) {
                    const t = dr(r);
                    return t.isNeg() && Nr("division-by-zero", "mod"), Er(dr(this).umod(t))
                }
                pow(r) {
                    const t = dr(r);
                    return t.isNeg() && Nr("negative-power", "pow"), Er(dr(this).pow(t))
                }
                and(r) {
                    const t = dr(r);
                    return (this.isNegative() || t.isNeg()) && Nr("unbound-bitwise-result", "and"), Er(dr(this).and(t))
                }
                or(r) {
                    const t = dr(r);
                    return (this.isNegative() || t.isNeg()) && Nr("unbound-bitwise-result", "or"), Er(dr(this).or(t))
                }
                xor(r) {
                    const t = dr(r);
                    return (this.isNegative() || t.isNeg()) && Nr("unbound-bitwise-result", "xor"), Er(dr(this).xor(t))
                }
                mask(r) {
                    return (this.isNegative() || r < 0) && Nr("negative-width", "mask"), Er(dr(this).maskn(r))
                }
                shl(r) {
                    return (this.isNegative() || r < 0) && Nr("negative-width", "shl"), Er(dr(this).shln(r))
                }
                shr(r) {
                    return (this.isNegative() || r < 0) && Nr("negative-width", "shr"), Er(dr(this).shrn(r))
                }
                eq(r) {
                    return dr(this).eq(dr(r))
                }
                lt(r) {
                    return dr(this).lt(dr(r))
                }
                lte(r) {
                    return dr(this).lte(dr(r))
                }
                gt(r) {
                    return dr(this).gt(dr(r))
                }
                gte(r) {
                    return dr(this).gte(dr(r))
                }
                isNegative() {
                    return "-" === this._hex[0]
                }
                isZero() {
                    return dr(this).isZero()
                }
                toNumber() {
                    try {
                        return dr(this).toNumber()
                    } catch (r) {
                        Nr("overflow", "toNumber", this.toString())
                    }
                    return null
                }
                toBigInt() {
                    try {
                        return BigInt(this.toString())
                    } catch (r) {}
                    return ur.throwError("this platform does not support BigInt", Z.errors.UNSUPPORTED_OPERATION, {
                        value: this.toString()
                    })
                }
                toString() {
                    return arguments.length > 0 && (10 === arguments[0] ? lr || (lr = !0, ur.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : 16 === arguments[0] ? ur.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Z.errors.UNEXPECTED_ARGUMENT, {}) : ur.throwError("BigNumber.toString does not accept parameters", Z.errors.UNEXPECTED_ARGUMENT, {})), dr(this).toString(10)
                }
                toHexString() {
                    return this._hex
                }
                toJSON(r) {
                    return {
                        type: "BigNumber",
                        hex: this.toHexString()
                    }
                }
                static from(r) {
                    if (r instanceof fr) return r;
                    if ("string" == typeof r) return r.match(/^-?0x[0-9a-f]+$/i) ? new fr(ar, gr(r)) : r.match(/^-?[0-9]+$/) ? new fr(ar, gr(new sr(r))) : ur.throwArgumentError("invalid BigNumber string", "value", r);
                    if ("number" == typeof r) return r % 1 && Nr("underflow", "BigNumber.from", r), (r >= cr || r <= -cr) && Nr("overflow", "BigNumber.from", r), fr.from(String(r));
                    const t = r;
                    if ("bigint" == typeof t) return fr.from(t.toString());
                    if (er(t)) return fr.from(ir(t));
                    if (t)
                        if (t.toHexString) {
                            const r = t.toHexString();
                            if ("string" == typeof r) return fr.from(r)
                        } else {
                            let r = t._hex;
                            if (null == r && "BigNumber" === t.type && (r = t.hex), "string" == typeof r && (nr(r) || "-" === r[0] && nr(r.substring(1)))) return fr.from(r)
                        }
                    return ur.throwArgumentError("invalid BigNumber value", "value", r)
                }
                static isBigNumber(r) {
                    return !(!r || !r._isBigNumber)
                }
            }

            function gr(r) {
                if ("string" != typeof r) return gr(r.toString(16));
                if ("-" === r[0]) return "-" === (r = r.substring(1))[0] && ur.throwArgumentError("invalid hex", "value", r), "0x00" === (r = gr(r)) ? r : "-" + r;
                if ("0x" !== r.substring(0, 2) && (r = "0x" + r), "0x" === r) return "0x00";
                for (r.length % 2 && (r = "0x0" + r.substring(2)); r.length > 4 && "0x00" === r.substring(0, 4);) r = "0x" + r.substring(4);
                return r
            }

            function Er(r) {
                return fr.from(gr(r))
            }

            function dr(r) {
                const t = fr.from(r).toHexString();
                return "-" === t[0] ? new sr("-" + t.substring(3), 16) : new sr(t.substring(2), 16)
            }

            function Nr(r, t, e) {
                const n = {
                    fault: r,
                    operation: t
                };
                return null != e && (n.value = e), ur.throwError(r, Z.errors.NUMERIC_FAULT, n)
            }
            var mr = e(79),
                Rr = e.n(mr);

            function pr(data) {
                return "0x" + Rr.a.keccak_256(v(data))
            }
            const Ar = new S("rlp/5.7.0");

            function Ir(r) {
                const t = [];
                for (; r;) t.unshift(255 & r), r >>= 8;
                return t
            }

            function wr(object) {
                if (Array.isArray(object)) {
                    let r = [];
                    if (object.forEach((function(t) {
                            r = r.concat(wr(t))
                        })), r.length <= 55) return r.unshift(192 + r.length), r;
                    const t = Ir(r.length);
                    return t.unshift(247 + t.length), t.concat(r)
                }
                O(object) || Ar.throwArgumentError("RLP object must be BytesLike", "object", object);
                const data = Array.prototype.slice.call(v(object));
                if (1 === data.length && data[0] <= 127) return data;
                if (data.length <= 55) return data.unshift(128 + data.length), data;
                const r = Ir(data.length);
                return r.unshift(183 + r.length), r.concat(data)
            }

            function Ur(object) {
                return M(wr(object))
            }
            const Sr = new S("address/5.5.0");

            function Tr(address) {
                D(address, 20) || Sr.throwArgumentError("invalid address", "address", address);
                const r = (address = address.toLowerCase()).substring(2).split(""),
                    t = new Uint8Array(40);
                for (let i = 0; i < 40; i++) t[i] = r[i].charCodeAt(0);
                const e = v(pr(t));
                for (let i = 0; i < 40; i += 2) e[i >> 1] >> 4 >= 8 && (r[i] = r[i].toUpperCase()), (15 & e[i >> 1]) >= 8 && (r[i + 1] = r[i + 1].toUpperCase());
                return "0x" + r.join("")
            }
            const _r = {};
            for (let i = 0; i < 10; i++) _r[String(i)] = String(i);
            for (let i = 0; i < 26; i++) _r[String.fromCharCode(65 + i)] = String(10 + i);
            const yr = Math.floor((Or = 9007199254740991, Math.log10 ? Math.log10(Or) : Math.log(Or) / Math.LN10));
            var Or;

            function Cr(address) {
                let r = (address = (address = address.toUpperCase()).substring(4) + address.substring(0, 2) + "00").split("").map((r => _r[r])).join("");
                for (; r.length >= yr;) {
                    let t = r.substring(0, yr);
                    r = parseInt(t, 10) % 97 + r.substring(t.length)
                }
                let t = String(98 - parseInt(r, 10) % 97);
                for (; t.length < 2;) t = "0" + t;
                return t
            }

            function Pr(address) {
                let r = null;
                if ("string" != typeof address && Sr.throwArgumentError("invalid address", "address", address), address.match(/^(0x)?[0-9a-fA-F]{40}$/)) "0x" !== address.substring(0, 2) && (address = "0x" + address), r = Tr(address), address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && r !== address && Sr.throwArgumentError("bad address checksum", "address", address);
                else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
                    for (address.substring(2, 4) !== Cr(address) && Sr.throwArgumentError("bad icap checksum", "address", address), t = address.substring(4), r = new sr(t, 36).toString(16); r.length < 40;) r = "0" + r;
                    r = Tr("0x" + r)
                } else Sr.throwArgumentError("invalid address", "address", address);
                var t;
                return r
            }

            function vr(address) {
                try {
                    return Pr(address), !0
                } catch (r) {}
                return !1
            }

            function xr(address) {
                let r = (t = Pr(address).substring(2), new sr(t, 16).toString(36)).toUpperCase();
                for (var t; r.length < 30;) r = "0" + r;
                return "XE" + Cr("XE00" + r) + r
            }

            function Dr(r) {
                let t = null;
                try {
                    t = Pr(r.from)
                } catch (t) {
                    Sr.throwArgumentError("missing from address", "transaction", r)
                }
                return Pr(k(pr(Ur([t, function(r) {
                    let t = v(r);
                    if (0 === t.length) return t;
                    let e = 0;
                    for (; e < t.length && 0 === t[e];) e++;
                    return e && (t = t.slice(e)), t
                }(v(fr.from(r.nonce).toHexString()))])), 12))
            }

            function Lr(r, t, e) {
                return 32 !== F(t) && Sr.throwArgumentError("salt must be 32 bytes", "salt", t), 32 !== F(e) && Sr.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", e), Pr(k(pr(x(["0xff", Pr(r), t, e])), 12))
            }
            var Mr = e(1036),
                Fr = e(1034),
                kr = e(119),
                Gr = e(1774),
                Br = e(1784),
                Wr = e(623),
                zr = e(1779),
                Xr = e(236),
                jr = e(1777),
                Kr = e(1078),
                Hr = e(377),
                Vr = e(1780),
                Jr = e(453),
                $r = e(1775),
                Zr = e(1776),
                qr = e(276),
                Qr = e(1035),
                Yr = e(447),
                tt = e(1773),
                et = e(225),
                nt = e(1783),
                ot = e(275),
                it = e(317),
                st = e(370),
                ut = e(446),
                at = e(1107);
            new Hr.a("ethers/5.5.3")
        }
    }
]);