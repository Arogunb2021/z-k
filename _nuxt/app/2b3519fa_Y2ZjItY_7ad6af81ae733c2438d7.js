(window.webpackJsonp = window.webpackJsonp || []).push([
    [55], {
        1694: function(e, t, r) {
            "use strict";
            r.d(t, "a", (function() {
                return d
            }));
            var n = r(399);
            let o = null;

            function l(e) {
                if (null == o && (o = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60" !== n.a.check(e))) throw o = null, new Error("BIP39 Wordlist for en (English) FAILED")
            }
            class c extends n.a {
                constructor() {
                    super("en")
                }
                getWord(e) {
                    return l(this), o[e]
                }
                getWordIndex(e) {
                    return l(this), o.indexOf(e)
                }
            }
            const h = new c;
            n.a.register(h);
            const d = {
                en: h
            }
        },
        177: function(e, t, r) {
            "use strict";
            var n, o = "object" == typeof Reflect ? Reflect : null,
                l = o && "function" == typeof o.apply ? o.apply : function(e, t, r) {
                    return Function.prototype.apply.call(e, t, r)
                };
            n = o && "function" == typeof o.ownKeys ? o.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
            } : function(e) {
                return Object.getOwnPropertyNames(e)
            };
            var c = Number.isNaN || function(e) {
                return e != e
            };

            function h() {
                h.init.call(this)
            }
            e.exports = h, e.exports.once = function(e, t) {
                return new Promise((function(r, n) {
                    function o(r) {
                        e.removeListener(t, l), n(r)
                    }

                    function l() {
                        "function" == typeof e.removeListener && e.removeListener("error", o), r([].slice.call(arguments))
                    }
                    A(e, t, l, {
                        once: !0
                    }), "error" !== t && function(e, t, r) {
                        "function" == typeof e.on && A(e, "error", t, r)
                    }(e, o, {
                        once: !0
                    })
                }))
            }, h.EventEmitter = h, h.prototype._events = void 0, h.prototype._eventsCount = 0, h.prototype._maxListeners = void 0;
            var d = 10;

            function f(e) {
                if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
            }

            function y(e) {
                return void 0 === e._maxListeners ? h.defaultMaxListeners : e._maxListeners
            }

            function m(e, t, r, n) {
                var o, l, c, h;
                if (f(r), void 0 === (l = e._events) ? (l = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== l.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), l = e._events), c = l[t]), void 0 === c) c = l[t] = r, ++e._eventsCount;
                else if ("function" == typeof c ? c = l[t] = n ? [r, c] : [c, r] : n ? c.unshift(r) : c.push(r), (o = y(e)) > 0 && c.length > o && !c.warned) {
                    c.warned = !0;
                    var d = new Error("Possible EventEmitter memory leak detected. " + c.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    d.name = "MaxListenersExceededWarning", d.emitter = e, d.type = t, d.count = c.length, h = d, console && console.warn && console.warn(h)
                }
                return e
            }

            function v() {
                if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }

            function S(e, t, r) {
                var n = {
                        fired: !1,
                        wrapFn: void 0,
                        target: e,
                        type: t,
                        listener: r
                    },
                    o = v.bind(n);
                return o.listener = r, n.wrapFn = o, o
            }

            function C(e, t, r) {
                var n = e._events;
                if (void 0 === n) return [];
                var o = n[t];
                return void 0 === o ? [] : "function" == typeof o ? r ? [o.listener || o] : [o] : r ? function(e) {
                    for (var t = new Array(e.length), i = 0; i < t.length; ++i) t[i] = e[i].listener || e[i];
                    return t
                }(o) : E(o, o.length)
            }

            function w(e) {
                var t = this._events;
                if (void 0 !== t) {
                    var r = t[e];
                    if ("function" == typeof r) return 1;
                    if (void 0 !== r) return r.length
                }
                return 0
            }

            function E(e, t) {
                for (var r = new Array(t), i = 0; i < t; ++i) r[i] = e[i];
                return r
            }

            function A(e, t, r, n) {
                if ("function" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r);
                else {
                    if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                    e.addEventListener(t, (function o(l) {
                        n.once && e.removeEventListener(t, o), r(l)
                    }))
                }
            }
            Object.defineProperty(h, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return d
                },
                set: function(e) {
                    if ("number" != typeof e || e < 0 || c(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                    d = e
                }
            }), h.init = function() {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
            }, h.prototype.setMaxListeners = function(e) {
                if ("number" != typeof e || e < 0 || c(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                return this._maxListeners = e, this
            }, h.prototype.getMaxListeners = function() {
                return y(this)
            }, h.prototype.emit = function(e) {
                for (var t = [], i = 1; i < arguments.length; i++) t.push(arguments[i]);
                var r = "error" === e,
                    n = this._events;
                if (void 0 !== n) r = r && void 0 === n.error;
                else if (!r) return !1;
                if (r) {
                    var o;
                    if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
                    var c = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                    throw c.context = o, c
                }
                var h = n[e];
                if (void 0 === h) return !1;
                if ("function" == typeof h) l(h, this, t);
                else {
                    var d = h.length,
                        f = E(h, d);
                    for (i = 0; i < d; ++i) l(f[i], this, t)
                }
                return !0
            }, h.prototype.addListener = function(e, t) {
                return m(this, e, t, !1)
            }, h.prototype.on = h.prototype.addListener, h.prototype.prependListener = function(e, t) {
                return m(this, e, t, !0)
            }, h.prototype.once = function(e, t) {
                return f(t), this.on(e, S(this, e, t)), this
            }, h.prototype.prependOnceListener = function(e, t) {
                return f(t), this.prependListener(e, S(this, e, t)), this
            }, h.prototype.removeListener = function(e, t) {
                var r, n, o, i, l;
                if (f(t), void 0 === (n = this._events)) return this;
                if (void 0 === (r = n[e])) return this;
                if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t));
                else if ("function" != typeof r) {
                    for (o = -1, i = r.length - 1; i >= 0; i--)
                        if (r[i] === t || r[i].listener === t) {
                            l = r[i].listener, o = i;
                            break
                        }
                    if (o < 0) return this;
                    0 === o ? r.shift() : function(e, t) {
                        for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                        e.pop()
                    }(r, o), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", e, l || t)
                }
                return this
            }, h.prototype.off = h.prototype.removeListener, h.prototype.removeAllListeners = function(e) {
                var t, r, i;
                if (void 0 === (r = this._events)) return this;
                if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this;
                if (0 === arguments.length) {
                    var n, o = Object.keys(r);
                    for (i = 0; i < o.length; ++i) "removeListener" !== (n = o[i]) && this.removeAllListeners(n);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                }
                if ("function" == typeof(t = r[e])) this.removeListener(e, t);
                else if (void 0 !== t)
                    for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
                return this
            }, h.prototype.listeners = function(e) {
                return C(this, e, !0)
            }, h.prototype.rawListeners = function(e) {
                return C(this, e, !1)
            }, h.listenerCount = function(e, t) {
                return "function" == typeof e.listenerCount ? e.listenerCount(t) : w.call(e, t)
            }, h.prototype.listenerCount = w, h.prototype.eventNames = function() {
                return this._eventsCount > 0 ? n(this._events) : []
            }
        },
        278: function(e, t, r) {
            "use strict";
            r.r(t), r.d(t, "Wallet", (function() {
                return T
            })), r.d(t, "verifyMessage", (function() {
                return O
            })), r.d(t, "verifyTypedData", (function() {
                return L
            }));
            var n = r(34),
                o = r(171),
                l = r(156),
                c = r(0),
                h = r(558),
                d = r(481),
                f = r(90),
                y = r(48),
                m = r(5),
                v = r(332),
                S = r(137),
                C = r(320),
                w = r(381),
                E = r(59),
                A = r(7);
            var P = function(e, t, r, n) {
                return new(r || (r = Promise))((function(o, l) {
                    function c(e) {
                        try {
                            d(n.next(e))
                        } catch (e) {
                            l(e)
                        }
                    }

                    function h(e) {
                        try {
                            d(n.throw(e))
                        } catch (e) {
                            l(e)
                        }
                    }

                    function d(e) {
                        var t;
                        e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
                            e(t)
                        }))).then(c, h)
                    }
                    d((n = n.apply(e, t || [])).next())
                }))
            };
            const R = new A.Logger("wallet/5.6.0");
            class T extends l.a {
                constructor(e, t) {
                    if (R.checkNew(new.target, T), super(), null != (r = e) && Object(c.isHexString)(r.privateKey, 32) && null != r.address) {
                        const t = new S.SigningKey(e.privateKey);
                        if (Object(m.defineReadOnly)(this, "_signingKey", (() => t)), Object(m.defineReadOnly)(this, "address", Object(E.computeAddress)(this.publicKey)), this.address !== Object(n.getAddress)(e.address) && R.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), function(e) {
                                const t = e.mnemonic;
                                return t && t.phrase
                            }(e)) {
                            const t = e.mnemonic;
                            Object(m.defineReadOnly)(this, "_mnemonic", (() => ({
                                phrase: t.phrase,
                                path: t.path || f.defaultPath,
                                locale: t.locale || "en"
                            })));
                            const r = this.mnemonic,
                                n = f.HDNode.fromMnemonic(r.phrase, null, r.locale).derivePath(r.path);
                            Object(E.computeAddress)(n.privateKey) !== this.address && R.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]")
                        } else Object(m.defineReadOnly)(this, "_mnemonic", (() => null))
                    } else {
                        if (S.SigningKey.isSigningKey(e)) "secp256k1" !== e.curve && R.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), Object(m.defineReadOnly)(this, "_signingKey", (() => e));
                        else {
                            "string" == typeof e && e.match(/^[0-9a-f]*$/i) && 64 === e.length && (e = "0x" + e);
                            const t = new S.SigningKey(e);
                            Object(m.defineReadOnly)(this, "_signingKey", (() => t))
                        }
                        Object(m.defineReadOnly)(this, "_mnemonic", (() => null)), Object(m.defineReadOnly)(this, "address", Object(E.computeAddress)(this.publicKey))
                    }
                    var r;
                    t && !o.b.isProvider(t) && R.throwArgumentError("invalid provider", "provider", t), Object(m.defineReadOnly)(this, "provider", t || null)
                }
                get mnemonic() {
                    return this._mnemonic()
                }
                get privateKey() {
                    return this._signingKey().privateKey
                }
                get publicKey() {
                    return this._signingKey().publicKey
                }
                getAddress() {
                    return Promise.resolve(this.address)
                }
                connect(e) {
                    return new T(this, e)
                }
                signTransaction(e) {
                    return Object(m.resolveProperties)(e).then((t => {
                        null != t.from && (Object(n.getAddress)(t.from) !== this.address && R.throwArgumentError("transaction from address mismatch", "transaction.from", e.from), delete t.from);
                        const r = this._signingKey().signDigest(Object(y.keccak256)(Object(E.serialize)(t)));
                        return Object(E.serialize)(t, r)
                    }))
                }
                signMessage(e) {
                    return P(this, void 0, void 0, (function*() {
                        return Object(c.joinSignature)(this._signingKey().signDigest(Object(h.a)(e)))
                    }))
                }
                _signTypedData(e, t, r) {
                    return P(this, void 0, void 0, (function*() {
                        const n = yield d.a.resolveNames(e, t, r, (e => (null == this.provider && R.throwError("cannot resolve ENS names without a provider", A.Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "resolveName",
                            value: e
                        }), this.provider.resolveName(e))));
                        return Object(c.joinSignature)(this._signingKey().signDigest(d.a.hash(n.domain, t, n.value)))
                    }))
                }
                encrypt(e, t, r) {
                    if ("function" != typeof t || r || (r = t, t = {}), r && "function" != typeof r) throw new Error("invalid callback");
                    return t || (t = {}), Object(C.c)(this, e, t, r)
                }
                static createRandom(e) {
                    let t = Object(v.a)(16);
                    e || (e = {}), e.extraEntropy && (t = Object(c.arrayify)(Object(c.hexDataSlice)(Object(y.keccak256)(Object(c.concat)([t, e.extraEntropy])), 0, 16)));
                    const r = Object(f.entropyToMnemonic)(t, e.locale);
                    return T.fromMnemonic(r, e.path, e.locale)
                }
                static fromEncryptedJson(e, t, r) {
                    return Object(w.decryptJsonWallet)(e, t, r).then((e => new T(e)))
                }
                static fromEncryptedJsonSync(e, t) {
                    return new T(Object(w.decryptJsonWalletSync)(e, t))
                }
                static fromMnemonic(e, path, t) {
                    return path || (path = f.defaultPath), new T(f.HDNode.fromMnemonic(e, null, t).derivePath(path))
                }
            }

            function O(e, t) {
                return Object(E.recoverAddress)(Object(h.a)(e), t)
            }

            function L(e, t, r, n) {
                return Object(E.recoverAddress)(d.a.hash(e, t, r), n)
            }
        },
        298: function(e, t, r) {
            "use strict";
            (function(t) {
                var n = r(878),
                    o = r(1605);

                function l(e) {
                    var a = e;
                    if ("string" != typeof a) throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a + ", while padToEven.");
                    return a.length % 2 && (a = "0" + a), a
                }

                function c(i) {
                    return "0x" + i.toString(16)
                }
                e.exports = {
                    arrayContainsArray: function(e, t, r) {
                        if (!0 !== Array.isArray(e)) throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof e + "'");
                        if (!0 !== Array.isArray(t)) throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof t + "'");
                        return t[Boolean(r) ? "some" : "every"]((function(t) {
                            return e.indexOf(t) >= 0
                        }))
                    },
                    intToBuffer: function(i) {
                        var e = c(i);
                        return new t(l(e.slice(2)), "hex")
                    },
                    getBinarySize: function(e) {
                        if ("string" != typeof e) throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof e + "'.");
                        return t.byteLength(e, "utf8")
                    },
                    isHexPrefixed: n,
                    stripHexPrefix: o,
                    padToEven: l,
                    intToHex: c,
                    fromAscii: function(e) {
                        for (var t = "", i = 0; i < e.length; i++) {
                            var r = e.charCodeAt(i).toString(16);
                            t += r.length < 2 ? "0" + r : r
                        }
                        return "0x" + t
                    },
                    fromUtf8: function(e) {
                        return "0x" + l(new t(e, "utf8").toString("hex")).replace(/^0+|0+$/g, "")
                    },
                    toAscii: function(e) {
                        var t = "",
                            i = 0,
                            r = e.length;
                        for ("0x" === e.substring(0, 2) && (i = 2); i < r; i += 2) {
                            var code = parseInt(e.substr(i, 2), 16);
                            t += String.fromCharCode(code)
                        }
                        return t
                    },
                    toUtf8: function(e) {
                        return new t(l(o(e).replace(/^0+|0+$/g, "")), "hex").toString("utf8")
                    },
                    getKeys: function(e, t, r) {
                        if (!Array.isArray(e)) throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof e + "'");
                        if ("string" != typeof t) throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof t + "'.");
                        for (var n = [], i = 0; i < e.length; i++) {
                            var o = e[i][t];
                            if (r && !o) o = "";
                            else if ("string" != typeof o) throw new Error("invalid abi");
                            n.push(o)
                        }
                        return n
                    },
                    isHexString: function(e, t) {
                        return !("string" != typeof e || !e.match(/^0x[0-9A-Fa-f]*$/)) && (!t || e.length === 2 + 2 * t)
                    }
                }
            }).call(this, r(33).Buffer)
        },
        364: function(e, t, r) {
            "use strict";
            var n = Object.prototype.hasOwnProperty,
                o = "~";

            function l() {}

            function c(e, t, r) {
                this.fn = e, this.context = t, this.once = r || !1
            }

            function h(e, t, r, n, l) {
                if ("function" != typeof r) throw new TypeError("The listener must be a function");
                var h = new c(r, n || e, l),
                    d = o ? o + t : t;
                return e._events[d] ? e._events[d].fn ? e._events[d] = [e._events[d], h] : e._events[d].push(h) : (e._events[d] = h, e._eventsCount++), e
            }

            function d(e, t) {
                0 == --e._eventsCount ? e._events = new l : delete e._events[t]
            }

            function f() {
                this._events = new l, this._eventsCount = 0
            }
            Object.create && (l.prototype = Object.create(null), (new l).__proto__ || (o = !1)), f.prototype.eventNames = function() {
                var e, t, r = [];
                if (0 === this._eventsCount) return r;
                for (t in e = this._events) n.call(e, t) && r.push(o ? t.slice(1) : t);
                return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r
            }, f.prototype.listeners = function(e) {
                var t = o ? o + e : e,
                    r = this._events[t];
                if (!r) return [];
                if (r.fn) return [r.fn];
                for (var i = 0, n = r.length, l = new Array(n); i < n; i++) l[i] = r[i].fn;
                return l
            }, f.prototype.listenerCount = function(e) {
                var t = o ? o + e : e,
                    r = this._events[t];
                return r ? r.fn ? 1 : r.length : 0
            }, f.prototype.emit = function(e, t, r, n, l, c) {
                var h = o ? o + e : e;
                if (!this._events[h]) return !1;
                var d, i, f = this._events[h],
                    y = arguments.length;
                if (f.fn) {
                    switch (f.once && this.removeListener(e, f.fn, void 0, !0), y) {
                        case 1:
                            return f.fn.call(f.context), !0;
                        case 2:
                            return f.fn.call(f.context, t), !0;
                        case 3:
                            return f.fn.call(f.context, t, r), !0;
                        case 4:
                            return f.fn.call(f.context, t, r, n), !0;
                        case 5:
                            return f.fn.call(f.context, t, r, n, l), !0;
                        case 6:
                            return f.fn.call(f.context, t, r, n, l, c), !0
                    }
                    for (i = 1, d = new Array(y - 1); i < y; i++) d[i - 1] = arguments[i];
                    f.fn.apply(f.context, d)
                } else {
                    var m, v = f.length;
                    for (i = 0; i < v; i++) switch (f[i].once && this.removeListener(e, f[i].fn, void 0, !0), y) {
                        case 1:
                            f[i].fn.call(f[i].context);
                            break;
                        case 2:
                            f[i].fn.call(f[i].context, t);
                            break;
                        case 3:
                            f[i].fn.call(f[i].context, t, r);
                            break;
                        case 4:
                            f[i].fn.call(f[i].context, t, r, n);
                            break;
                        default:
                            if (!d)
                                for (m = 1, d = new Array(y - 1); m < y; m++) d[m - 1] = arguments[m];
                            f[i].fn.apply(f[i].context, d)
                    }
                }
                return !0
            }, f.prototype.on = function(e, t, r) {
                return h(this, e, t, r, !1)
            }, f.prototype.once = function(e, t, r) {
                return h(this, e, t, r, !0)
            }, f.prototype.removeListener = function(e, t, r, n) {
                var l = o ? o + e : e;
                if (!this._events[l]) return this;
                if (!t) return d(this, l), this;
                var c = this._events[l];
                if (c.fn) c.fn !== t || n && !c.once || r && c.context !== r || d(this, l);
                else {
                    for (var i = 0, h = [], f = c.length; i < f; i++)(c[i].fn !== t || n && !c[i].once || r && c[i].context !== r) && h.push(c[i]);
                    h.length ? this._events[l] = 1 === h.length ? h[0] : h : d(this, l)
                }
                return this
            }, f.prototype.removeAllListeners = function(e) {
                var t;
                return e ? (t = o ? o + e : e, this._events[t] && d(this, t)) : (this._events = new l, this._eventsCount = 0), this
            }, f.prototype.off = f.prototype.removeListener, f.prototype.addListener = f.prototype.on, f.prefixed = o, f.EventEmitter = f, e.exports = f
        },
        399: function(e, t, r) {
            "use strict";
            r.d(t, "a", (function() {
                return h
            }));
            var n = r(223),
                o = r(5),
                l = r(7);
            const c = new l.Logger("wordlists/5.6.0");
            class h {
                constructor(e) {
                    c.checkAbstract(new.target, h), Object(o.defineReadOnly)(this, "locale", e)
                }
                split(e) {
                    return e.toLowerCase().split(/ +/g)
                }
                join(e) {
                    return e.join(" ")
                }
                static check(e) {
                    const t = [];
                    for (let i = 0; i < 2048; i++) {
                        const r = e.getWord(i);
                        if (i !== e.getWordIndex(r)) return "0x";
                        t.push(r)
                    }
                    return Object(n.a)(t.join("\n") + "\n")
                }
                static register(e, t) {
                    t || (t = e.locale)
                }
            }
        },
        99: function(e, t, r) {
            "use strict";
            r.r(t), r.d(t, "_fetchData", (function() {
                return C
            })), r.d(t, "fetchJson", (function() {
                return w
            })), r.d(t, "poll", (function() {
                return E
            }));
            var n = r(557),
                o = r(0),
                l = r(5),
                c = r(60),
                h = r(7);
            var d = function(e, t, r, n) {
                return new(r || (r = Promise))((function(o, l) {
                    function c(e) {
                        try {
                            d(n.next(e))
                        } catch (e) {
                            l(e)
                        }
                    }

                    function h(e) {
                        try {
                            d(n.throw(e))
                        } catch (e) {
                            l(e)
                        }
                    }

                    function d(e) {
                        var t;
                        e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
                            e(t)
                        }))).then(c, h)
                    }
                    d((n = n.apply(e, t || [])).next())
                }))
            };

            function f(e, t) {
                return d(this, void 0, void 0, (function*() {
                    null == t && (t = {});
                    const r = {
                        method: t.method || "GET",
                        headers: t.headers || {},
                        body: t.body || void 0
                    };
                    !0 !== t.skipFetchSetup && (r.mode = "cors", r.cache = "no-cache", r.credentials = "same-origin", r.redirect = "follow", r.referrer = "client");
                    const n = yield fetch(e, r), body = yield n.arrayBuffer(), l = {};
                    return n.headers.forEach ? n.headers.forEach(((e, t) => {
                        l[t.toLowerCase()] = e
                    })) : n.headers.keys().forEach((e => {
                        l[e.toLowerCase()] = n.headers.get(e)
                    })), {
                        headers: l,
                        statusCode: n.status,
                        statusMessage: n.statusText,
                        body: Object(o.arrayify)(new Uint8Array(body))
                    }
                }))
            }
            var y = function(e, t, r, n) {
                return new(r || (r = Promise))((function(o, l) {
                    function c(e) {
                        try {
                            d(n.next(e))
                        } catch (e) {
                            l(e)
                        }
                    }

                    function h(e) {
                        try {
                            d(n.throw(e))
                        } catch (e) {
                            l(e)
                        }
                    }

                    function d(e) {
                        var t;
                        e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
                            e(t)
                        }))).then(c, h)
                    }
                    d((n = n.apply(e, t || [])).next())
                }))
            };
            const m = new h.Logger("web/5.6.0");

            function v(e) {
                return new Promise((t => {
                    setTimeout(t, e)
                }))
            }

            function S(e, t) {
                if (null == e) return null;
                if ("string" == typeof e) return e;
                if (Object(o.isBytesLike)(e)) {
                    if (t && ("text" === t.split("/")[0] || "application/json" === t.split(";")[0].trim())) try {
                        return Object(c.h)(e)
                    } catch (e) {}
                    return Object(o.hexlify)(e)
                }
                return e
            }

            function C(e, body, t) {
                const r = "object" == typeof e && null != e.throttleLimit ? e.throttleLimit : 12;
                m.assertArgument(r > 0 && r % 1 == 0, "invalid connection throttle limit", "connection.throttleLimit", r);
                const o = "object" == typeof e ? e.throttleCallback : null,
                    l = "object" == typeof e && "number" == typeof e.throttleSlotInterval ? e.throttleSlotInterval : 100;
                m.assertArgument(l > 0 && l % 1 == 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", l);
                const d = "object" == typeof e && !!e.errorPassThrough,
                    C = {};
                let w = null;
                const E = {
                    method: "GET"
                };
                let A = !1,
                    P = 12e4;
                if ("string" == typeof e) w = e;
                else if ("object" == typeof e) {
                    if (null != e && null != e.url || m.throwArgumentError("missing URL", "connection.url", e), w = e.url, "number" == typeof e.timeout && e.timeout > 0 && (P = e.timeout), e.headers)
                        for (const t in e.headers) C[t.toLowerCase()] = {
                            key: t,
                            value: String(e.headers[t])
                        }, ["if-none-match", "if-modified-since"].indexOf(t.toLowerCase()) >= 0 && (A = !0);
                    if (E.allowGzip = !!e.allowGzip, null != e.user && null != e.password) {
                        "https:" !== w.substring(0, 6) && !0 !== e.allowInsecureAuthentication && m.throwError("basic authentication requires a secure https url", h.Logger.errors.INVALID_ARGUMENT, {
                            argument: "url",
                            url: w,
                            user: e.user,
                            password: "[REDACTED]"
                        });
                        const t = e.user + ":" + e.password;
                        C.authorization = {
                            key: "Authorization",
                            value: "Basic " + Object(n.b)(Object(c.f)(t))
                        }
                    }
                    null != e.skipFetchSetup && (E.skipFetchSetup = !!e.skipFetchSetup)
                }
                const R = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
                    T = w ? w.match(R) : null;
                if (T) try {
                    const e = {
                        statusCode: 200,
                        statusMessage: "OK",
                        headers: {
                            "content-type": T[1]
                        },
                        body: Object(n.a)(T[2])
                    };
                    let r = e.body;
                    return t && (r = t(e.body, e)), Promise.resolve(r)
                } catch (e) {
                    m.throwError("processing response error", h.Logger.errors.SERVER_ERROR, {
                        body: S(T[1], T[2]),
                        error: e,
                        requestBody: null,
                        requestMethod: "GET",
                        url: w
                    })
                }
                body && (E.method = "POST", E.body = body, null == C["content-type"] && (C["content-type"] = {
                    key: "Content-Type",
                    value: "application/octet-stream"
                }), null == C["content-length"] && (C["content-length"] = {
                    key: "Content-Length",
                    value: String(body.length)
                }));
                const O = {};
                Object.keys(C).forEach((e => {
                    const header = C[e];
                    O[header.key] = header.value
                })), E.headers = O;
                const L = function() {
                        let e = null;
                        return {
                            promise: new Promise((function(t, r) {
                                P && (e = setTimeout((() => {
                                    null != e && (e = null, r(m.makeError("timeout", h.Logger.errors.TIMEOUT, {
                                        requestBody: S(E.body, O["content-type"]),
                                        requestMethod: E.method,
                                        timeout: P,
                                        url: w
                                    })))
                                }), P))
                            })),
                            cancel: function() {
                                null != e && (clearTimeout(e), e = null)
                            }
                        }
                    }(),
                    k = function() {
                        return y(this, void 0, void 0, (function*() {
                            for (let e = 0; e < r; e++) {
                                let n = null;
                                try {
                                    if (n = yield f(w, E), e < r)
                                        if (301 === n.statusCode || 302 === n.statusCode) {
                                            const e = n.headers.location || "";
                                            if ("GET" === E.method && e.match(/^https:/)) {
                                                w = n.headers.location;
                                                continue
                                            }
                                        } else if (429 === n.statusCode) {
                                        let t = !0;
                                        if (o && (t = yield o(e, w)), t) {
                                            let t = 0;
                                            const r = n.headers["retry-after"];
                                            t = "string" == typeof r && r.match(/^[1-9][0-9]*$/) ? 1e3 * parseInt(r) : l * parseInt(String(Math.random() * Math.pow(2, e))), yield v(t);
                                            continue
                                        }
                                    }
                                } catch (e) {
                                    n = e.response, null == n && (L.cancel(), m.throwError("missing response", h.Logger.errors.SERVER_ERROR, {
                                        requestBody: S(E.body, O["content-type"]),
                                        requestMethod: E.method,
                                        serverError: e,
                                        url: w
                                    }))
                                }
                                let body = n.body;
                                if (A && 304 === n.statusCode ? body = null : !d && (n.statusCode < 200 || n.statusCode >= 300) && (L.cancel(), m.throwError("bad response", h.Logger.errors.SERVER_ERROR, {
                                        status: n.statusCode,
                                        headers: n.headers,
                                        body: S(body, n.headers ? n.headers["content-type"] : null),
                                        requestBody: S(E.body, O["content-type"]),
                                        requestMethod: E.method,
                                        url: w
                                    })), t) try {
                                    const e = yield t(body, n);
                                    return L.cancel(), e
                                } catch (t) {
                                    if (t.throttleRetry && e < r) {
                                        let t = !0;
                                        if (o && (t = yield o(e, w)), t) {
                                            const t = l * parseInt(String(Math.random() * Math.pow(2, e)));
                                            yield v(t);
                                            continue
                                        }
                                    }
                                    L.cancel(), m.throwError("processing response error", h.Logger.errors.SERVER_ERROR, {
                                        body: S(body, n.headers ? n.headers["content-type"] : null),
                                        error: t,
                                        requestBody: S(E.body, O["content-type"]),
                                        requestMethod: E.method,
                                        url: w
                                    })
                                }
                                return L.cancel(), body
                            }
                            return m.throwError("failed response", h.Logger.errors.SERVER_ERROR, {
                                requestBody: S(E.body, O["content-type"]),
                                requestMethod: E.method,
                                url: w
                            })
                        }))
                    }();
                return Promise.race([L.promise, k])
            }

            function w(e, t, r) {
                let body = null;
                if (null != t) {
                    body = Object(c.f)(t);
                    const r = "string" == typeof e ? {
                        url: e
                    } : Object(l.shallowCopy)(e);
                    if (r.headers) {
                        0 !== Object.keys(r.headers).filter((e => "content-type" === e.toLowerCase())).length || (r.headers = Object(l.shallowCopy)(r.headers), r.headers["content-type"] = "application/json")
                    } else r.headers = {
                        "content-type": "application/json"
                    };
                    e = r
                }
                return C(e, body, ((e, t) => {
                    let n = null;
                    if (null != e) try {
                        n = JSON.parse(Object(c.h)(e))
                    } catch (t) {
                        m.throwError("invalid JSON", h.Logger.errors.SERVER_ERROR, {
                            body: e,
                            error: t
                        })
                    }
                    return r && (n = r(n, t)), n
                }))
            }

            function E(e, t) {
                return t || (t = {}), null == (t = Object(l.shallowCopy)(t)).floor && (t.floor = 0), null == t.ceiling && (t.ceiling = 1e4), null == t.interval && (t.interval = 250), new Promise((function(r, n) {
                    let o = null,
                        l = !1;
                    const c = () => !l && (l = !0, o && clearTimeout(o), !0);
                    t.timeout && (o = setTimeout((() => {
                        c() && n(new Error("timeout"))
                    }), t.timeout));
                    const h = t.retryLimit;
                    let d = 0;
                    ! function o() {
                        return e().then((function(e) {
                            if (void 0 !== e) c() && r(e);
                            else if (t.oncePoll) t.oncePoll.once("poll", o);
                            else if (t.onceBlock) t.onceBlock.once("block", o);
                            else if (!l) {
                                if (d++, d > h) return void(c() && n(new Error("retry limit reached")));
                                let e = t.interval * parseInt(String(Math.random() * Math.pow(2, d)));
                                e < t.floor && (e = t.floor), e > t.ceiling && (e = t.ceiling), setTimeout(o, e)
                            }
                            return null
                        }), (function(e) {
                            c() && n(e)
                        }))
                    }()
                }))
            }
        }
    }
]);